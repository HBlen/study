第五章 继承

5.1 类、超类、子类
1. 在子类中可以增加域、 增加方法或覆盖超类的方法， 然而绝对 不能删除继承的任何域和方法。 
2. 可以通过 super 实现对超类构造器的调用。 使用 super 调用构造器的语句必须是子类构造器的第一条语句。 如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认(没有参数 ) 
的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器’ 则 Java 编译器将报告错误。 
3. 关键字 this 有两个用途 一是引用隐式参数 二是调用该类其他的构 ::， 
造器 ， 同样， super 关键字也有两个用途: 一是调用超类的方法， 二是调用超类的构造器。 
4. 一个对象变量(例如， 变量 e) 可以指示多种实际类型的现象被称为多态(polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamic binding。) 
5. 有一个用来判断是否应该设计为继承关系的简单规则， 这就是“ is-a” 规则， 它表明子类的每个对象也是超类的对象。 例如， 每个经理都是雇员， 因此， 将 Manager 类设计为 Employee 类的子类是显而易见的， 反 之不然， 并不是每一名雇员都是经理。 
“ is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以 用子类对象置换。 
6. 在覆盖一个方法的时候， 子类方法不能低于超类方法的可见性。 特别是， 如果超类 方法是 public, 子类方法一定要声明为 public。 经常会发生这类错误: 在声明子类方法的时 候， 遗漏了 public 修饰符。 此时， 编译器将会把它解释为试图提供更严格的访问权限 
7. 有时候， 可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果 在定义类的时候使用了 final 修饰符就表明这个类是 final 类。 
8. 类中的特定方法也可以被声明为 final 如果这样做，子类就不能覆盖这个方法 ，final类中的所有方法自动地成为 final 方法 

9. 前面曾经说过，域也可以被声明为fina。l 对于final域来说，构造对象之后就不允 许改变它们的值了。不过， 如果将一个类声明为 final， 只有其中的方法自动地成为 final, 而不包括域。 
10. 将方法或类声明为 final 主要目的是: 确保它们不会在子类中改变语义。 
11. 进行类型转换的唯一原因是: 在暂时忽视对象的实际类型之后， 使用对象的全部功能。 
12. •只能在继承层次内进行类型转换。 •在将超类转换成子类之前， 应该使用 instanceof 进行检查。 
13. 为了提高程序的清晰度， 包含一个或多个抽象方法的类本身必须被声明为抽象的。 
14. 扩展抽象类可以有两种选择。 一种是在抽象类中定义部分抽象类方法或不定义抽象类方法， 这样就必须将子类也标记为抽 象类; 另一种是定义全部的抽象方法， 这样一来， 子类就不是抽象的了。 
15. 类即使不含抽象方法， 也可以将类声明为抽象类。
抽象类不能被实例化。也就是说， 如果将一个类声明为 abstract, 就不能创建这个类的对 
象。 
16．下面归纳一下 Java 用于控制可见性的 4 个访问修饰符: 
1) 仅对本类可见 private。 
2) 对所有类可见 public:
3) 对本包和所有子类可见 protected。
4) 对本包可见—默认(很遗憾，) 不需要修饰符。 

5.2 Object类：所有类的超类
1. Java 语言规范要求 equals 方法具有下面的特性: 
1) 自反性: 对于任何非空引用 x, x.equals(?0 应该返回 truec 
2) 对称性: 对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true, x.equals(y) 也应该返 回 true。 
3) 传递性: 对于任何引用 x、 y 和 z, 如果 x.equals(y) 返 N true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。 
4) 一致性: 如果 x 和 y 引用的对象没有发生变化， 反复调用 x.eqimIS(y) 应该返回同样 的结果。 
5) 对于任意非空引用 x, x.equals(null) 应该返回 false, 
这些规则十分合乎情理， 从而避免了类库实现者在数据结构中定位一个元素时还要考虑 调用 x.equals(y), 还是调用 y.equals(x) 的问题。 
2. 下面给出编写一个完美的 equals 方法的建议:
1) 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。 
2) 检测 this 与 otherObject 是否引用同一个对象:
if (this = otherObject) return true; 
这条语句只是一个优化。 实际上， 这是一种经常采用的形式。 因为计算这个等式要比一 个一个地比较类中的域所付出的代价小得多。 
3) 检测 otherObject 是否为 null , 如 果 为 null , 返 回 false。 这项检测是很必要的。 if (otherObject = null) return false; 
4) 比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改 变， 就使用 getClass 检测: 
if (getClass() != otherObject.getCIassO) return false; 
如果所有的子类都拥有统一的语义， 就使用 instanceof 检测: if (!(otherObject instanceof ClassName)) return false; 
5) 将 otherObject 转换为相应的类类型变量: ClassName other = (ClassName) otherObject 
6)现在开始对所有需要比较的域进行比较了。使用= 比较基本类型域，使用equals比 较对象域。如果所有的域都匹配，就返回true; 否则返回false。 
3. 由于 hashCode 方法定义在 Object 类中， 因此每个对象都有一个默认的散列码， 其值为 对象的存储地址。 

5.3 泛型数组列表
1. 如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用 ensureCapacity 方法: staff.ensureCapacity(lOO) ; 这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100 次 add, 而不用重新分 配空间。 
另外， 还可以把初始容量传递给 ArrayList 构造器: ArrayList<Employee> staff = new ArrayListo(lOO); 
2. size 方法将返回数组列表中包含的实际元素数目。 例如， staff,sizeO 将返回 staff 数组列表的当前元素数量， 它等价于数组 a 的 a.length。 
3. 一旦能够确认数组列表的大小不再发生变化， 就可以调用 trimToSize 方法。这个方法将 
存储区域的大小调整为当前元素数量所需要的存储空间数目。 垃圾回收器将回收多余的存储 空间。 
一旦整理了数组列表的大小， 添加新元素就需要花时间再次移动存储块， 所以应该在确 认不会添加任何元素时， 再调用 trimToSize。 
4. 使用 get 和 set 方法实现访问或改变数组元素的操作， 例如， 要设置第 i 个元素， 可以使用: 
staff.set(i, harry): 
5. 使用 add 方法为数组添加新元素， 而不要使用 set 方法， 它只能替换数组中已经存在 的 元 素 内 容。 
使用下列格式获得数组列表的元素 : Employee e = staff.get(i); 

5.4 对象包装
1. 有时， 需要将 int 这样的基本类型转换为对象。 所有的基本类型都冇一个与之对应的类。 例如，丨nteger 类对应基本类型 in。t 通常， 这些类称为包装器 ( wrapper ) 
2. 自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和 int 被包装到固定的对象中。 

5.5 参数数量可变方法

5.6 枚举类
1. 在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“ = = ” 就 
可以了。
2. toString， 这个方法能够返回枚举常量名。 例如， Size.SMALL.toString( ) 将返回字符串 
“ SMALL”。
3. 每个枚举类型都有一个静态的 values 方法， 它将返回一个包含全部枚举值的数组。 
