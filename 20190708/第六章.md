第六章接口、lambda表达式与内部类
1.接口（interface）技术，主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以（implement）一个或多个接口，并在需要的地方，可以随时使用实现了相应接口的对象。
2．Lambda表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法（一个表示可执行代码块的简洁方法）。通过使用Lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码（用一种精巧的方式表示代码）。
3.内部类（innerclass）机制，内部类包含在另一个类中，该内部类中的方法可以访问其外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。
4.代理（proxy）是一种实现任何接口的对象。它可以用来构建系统级别的工具。

6.1接口
1.在 Java 中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。
2.接口中的所有方法自动地属于 public。 因此， 在接口中声明方法时， 不必提供关键字 public 。
3. 在接口 中还可以定义常量，然而， 更为重要的是要知道接口不能提供哪些功能。接口绝不能含 有实例域
4.为了让类实现一个接口， 通常需要下面两个步骤:
1 ) 将类声明为实现给定的接口。
2 ) 对接口中的所有方法进行定义。 要将类声明为实现某个接口， 需要使用关键字 implements: 
class Employee impleients Comparable

5.要了解更多接口（interface）技术，主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现（implement）一个或多个接口，并在需要的地方，可以随时使用实现了相应接口的对象。
一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突
6. 如同使用 instanceof检查一个对象是否属于某个特定类一样， 也可以使用 instance 检查一个对象是否实现了某个特定的接口:
if (anObject instanceof Comparable) { . . . }
与可以建立类的继承关系一样， 接口也可以被扩展。这里允许存在多条从具有较高通用 性的接口到较高专用性的接口的链。
7.与接口中的方法都自动地被设置为 public —样， 接口中的域将被自动设为 public static final
8.可以为接口方法提供一个默认实现。 必须用 default 修饰符标记这样一个方法。
9.解决默认方法冲突
1)超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
2)接口冲突。如果一个超接口提供了
10.千万不要让一个默认方法重新定义 Object 类中的某个方法。 

6.2接口实例
1.回调(callback) 是一种常见的程序设计模式。在这种模式中， 可以指出某个特定事件发 生时应该采取的动作。
2.对象克隆
对于每一个类， 需要确定:
1 ) 默认的 clone 方法是否满足要求;
2 ) 是否可以在可变的子对象上调用 clone 来修补默认的 clone 方法; 
3 ) 是否不该使用 clone（）
实际上第 3 个选项是默认选项。 如果选择第 1 项或第 2 项， 类必须: 1 ) 实现 Cloneable 接口;
2 ) 重新定义 clone 方法， 并指定 public 访问修饰符。

6.3lambda表达式
1.lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。
2.如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值， 这是不合法的。
3.对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达 式。 这种接口称为函数式接口 (functional interface )。
4.Timer t = new Timer(1000, Systei.out::println);
表达式 System.out::println 是一个方法引用(method reference), 它等价于 lambda 表达式 x 一> System.out.println(x)0
5.要用:: 操作符分隔方法名与对象或类名。 主要有 3 种情况: 
•object::instanceMethod
•Class ::static Method
•Class /.instanceMethod
在前 2 种情况中， 方法引用等价于提供方法参数的 lambda 表达式。 前面已经提到， System.out::println 等价于 x -> System.out.println(x。) 类似地， Math::pow 等价于(x，y) -> Math.pow(x, y。)
对于第 3 种情况， 第 1 个参数会成为方法的目标。例如， String::compareToIgnoreCase 等 同于 (x, y) -> x.compareToIgnoreCase(y)。
6. 构造器引用与方法引用很类似， 只不过方法名为 new。
7.lambda 表达式有 3个部分
1 ) 一个代码块;
2 ) 参数;
3 ) 自由变量的值， 这是指非参数而且不在代码中定义的变量。
8. 在 Java 中， 要确保所捕获 的值是明确定义的， 这里有一个重要的限制。在 lambda 表达式中， 只能引用值不会改变的 变量。
9.lambda 表达式中捕获的变量必须实际上是最终变量 ( effectively final ) 实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。
10.在方法中， 不能有两个同名的局部变量， 因此， lambda 表达式中同样也不能有同名的局 部变量。
11.使用 lambda 表达式的重点是延迟执行 deferred execution )
之所以希望以后再执行代码， 这有很多原因， 如:
•在一个单独的线程中运行代码;
•多次运行代码;
•在算法的适当位置运行代码(例如， 排序中的比较操作;) •发生某种情况时执行代码(如， 点击了一个按钮， 数据到达， 等等;) •只在必要时才运行代码。

6.5 代理
1.利用代理可以在运行时创建一个实现了一组给 定接口的新类，这种功能只有在编译时无法确定需要实现哪个接 口时才有必要使用。
