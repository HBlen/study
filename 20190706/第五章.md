第五章继承

5.1类、超类、子类
1.在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。Java采用super关键字调用超类方法
2.可以通过super实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句。如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认(没有参数)
的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。
3.关键字this有两个用途一是引用隐式参数二是调用该类其他的构造器，同样，super关键字也有两个用途:一是调用超类的方法，二是调用超类的构造器。
4.一个对象变量(例如，变量e)可以指示多种实际类型的现象被称为多态(polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamicbinding。)
5.有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。
“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。
6.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public,子类方法一定要声明为public。经常会发生这类错误:在声明子类方法的时候，遗漏了public修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限
7.有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。
8.类中的特定方法也可以被声明为final如果这样做，子类就不能覆盖这个方法，final类中的所有方法自动地成为final方法

9.域也可以被声明为final对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地成为final,而不包括域。
10.将方法或类声明为final主要目的是:确保它们不会在子类中改变语义。
11.进行类型转换的唯一原因是:在暂时忽视对象的实际类型之后，使用对象的全部功能。
12.•只能在继承层次内进行类型转换。•在将超类转换成子类之前，应该使用instanceof进行检查。
13.为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。
14.扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类;另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。
15.类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化。也就是说，如果将一个类声明为abstract,就不能创建这个类的对象。但可以定义一个抽象类变量，只能引用非抽象子类的对象
16．下面归纳一下Java用于控制可见性的4个访问修饰符:
1)仅对本类可见private。
2)对所有类可见public:
3)对本包和所有子类可见protected。
4)对本包可见—默认(很遗憾，)不需要修饰符。

5.2Object类：所有类的超类
1.可以使用Object类型的变量引用任何类型的对象
2.在Java中，只有基本类型不是对象，数值、字符、和布尔
1.Java语言规范要求equals方法具有下面的特性:
1)自反性:对于任何非空引用x,x.equals(?0应该返回truec
2)对称性:对于任何引用x和y,当且仅当y.equals(x)返回true,x.equals(y)也应该返回true。
3)传递性:对于任何引用x、y和z,如果x.equals(y)返Ntrue，y.equals(z)返回true,x.equals(z)也应该返回true。
4)一致性:如果x和y引用的对象没有发生变化，反复调用x.eqimIS(y)应该返回同样的结果。
5)对于任意非空引用x,x.equals(null)应该返回false,
这些规则十分合乎情理，从而避免了类库实现者在数据结构中定位一个元素时还要考虑调用x.equals(y),还是调用y.equals(x)的问题。
3.下面给出编写一个完美的equals方法的建议:
1)显式参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量。
2)检测this与otherObject是否引用同一个对象:
if(this=otherObject)returntrue;
这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。
3)检测otherObject是否为null,如果为null,返回false。这项检测是很必要的。if(otherObject=null)returnfalse;
4)比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测:
if(getClass()!=otherObject.getCIassO)returnfalse;
如果所有的子类都拥有统一的语义，就使用instanceof检测:if(!(otherObjectinstanceofClassName))returnfalse;
5)将otherObject转换为相应的类类型变量:ClassNameother=(ClassName)otherObject
6)现在开始对所有需要比较的域进行比较了。使用=比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true;否则返回false。

4.由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。
5.字符串的散列码是由内容导出
6.需要组合多个散列值时,可以调用ObjeCtS.hash并提供多个参数。
7.toString方法，它用于返回表示对象值的字符串
8.Object类定义了toString方法，用来打印输出对象所属的类名和散列码
9.
•ClassgetClass()
返回包含对象信息的类对象。稍后会看到Java提供了类运行时的描述，它的内容被封装在Class类中。
•booleanequals(ObjectotherObject)
比较两个对象是否相等，如果两个对象指向同一块存储区域，方法返回true;否则方法返回false。在自定义的类中，应该覆盖这个方法。
•StringtoString()
返冋描述该对象值的字符串。在自定义的类中，应该覆盖这个方法。
5.3泛型数组列表
1.如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法:staff.ensureCapacity(1OO);这个方法调用将分配一个包含100个对象的内部数组。然后调用100次add,而不用重新分配空间。
另外，还可以把初始容量传递给ArrayList构造器:ArrayList<Employee>staff=newArrayListo(1OO);
2.size方法将返回数组列表中包含的实际元素数目。例如，staff,sizeO将返回staff数组列表的当前元素数量，它等价于数组a的a.length。
3.一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。
一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用trimToSize。
4.使用get和set方法实现访问或改变数组元素的操作，例如，要设置第i个元素，可以使用:
staff.set(i,harry):
5.使用add方法为数组添加新元素，而不要使用set方法，它只能替换数组中已经存在的元素内容。
使用下列格式获得数组列表的元素:Employeee=staff.get(i);

5.4对象包装
1.有时，需要将int这样的基本类型转换为对象。所有的基本类型都冇一个与之对应的类。例如，Integer类对应基本类型in。t通常，这些类称为包装器(wrapper)
2.象包装器类是不可变的， 即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final, 因此不能定义它们的子类。
4.由于每个值分别包装在对象中，所以 ArrayList<lnteger> 的效率远远低于int[ ]数组。因此，应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更加重要。
3.== 运算符也可以应用于对象包装器对象， 只不过检测的是对象是否指向同一个存储区域
4.自动装箱规范要求boolean、byte、char127，介于-128~127之间的short和int被包装到固定的对象中。
5.Number parse(String s)
返回数字值，假设给定的 String 表示了一个数值。

5.5参数数量可变方法
1.用户自己也可以定义可变参数的方法，并将参数指定为任意类型，甚至是基本类型。 
2。允许将一个数组传递给可变参数方法的最后一个参数

5.6枚举类
1.在比较两个枚举类型的值时，永远不需要调用equals,而直接使用“==”就可以了。
2.toString，这个方法能够返回枚举常量名。例如，Size.SMALL.toString()将返回字符串
“SMALL”。
3.每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。
