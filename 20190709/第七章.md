第七章 异常、断言和日志
7.1 处理错误
1.如果由于出现错误而使得某些操作没有完成程序应该:
返回到一种安全状态，并能够让用户执行一些其他的命令;或者•允许用户保存所有操作的结果，并以妥善的方式终止程序
2.由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常:
派生于RuntimeException的异常包含下面几种情况:•错误的类型转换。
•数组访问越界
•访问null指针
不是派生于RuntimeException的异常包括:•试图在文件尾部后面读取数据。
试图打开一个不存在的文件•。
试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在,
3.Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查(unchecked)异常，所有其他的异常称为受查(checked)异常。这是两个很有用的术语，在后面还会用到。编译器将核查是否为所有的受査异常提供了异常处理器。
4.如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常。这个道理很简单:一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。
7.1.2声明受查异常
5.方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受査异常。
6.遇到下面4种情况时应该抛出异常:
1)调用一个抛出受査异常的方法，例如，FilelnputStream构造器。
2)程序运行过程中发现错误，并且利用throw语句抛出一个受查异常(下一节将详细地介绍throw语句)。
3)程序出现错误，例如，a[-l]=0会抛出一个ArraylndexOutOffloundsException这样的非受查异常。
4)Java虚拟机和运行时库出现的内部错误。
7.对于那些可能被他人使用的Java方法，应该根据异常规范(exceptionspecification),在方法的首部声明这个方法可能抛出的异常。
8.一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制(Error),要么就应该避免发生(RuntimeException)。如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。
7.1.3如何抛出异常
9.对于一个已经存在的异常类，将其抛出非常容易D1)找到一个合适的异常类。
2)创建这个类的一个对象。
3)将对象抛出。
在这种情况下:
一旦方法抛出了异常，这个方法就不可能返回到调用者。也就是说，不必为返回的默认值或错误代码担忧。
7.1.4创建异常类
10在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，创建自己的异常类就是一件顺理成章的事情了。我们需要做的只是定义一个派生于Exception的类，或者派生于Exception子类的类。例如，定义一个派生于IOException的类。习惯上，定义的类应该包含两个构造器，一个是默认的构造器;另一个是带有详细描述信息的构造器(超类Throwable的toString方法将会打印出这些详细信息，这在调试中非常有用

7.2捕获异常
1.如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么
1)程序将跳过try语句块的其余代码。
2)程序将执行catch子句中的处理器代码。
2.在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型，
3.final语句回收资源，断开数据库连接
不管是否有异常被捕获，finally子句中的代码都被执行。
4只要需要关闭资源，就要尽可能使用带资源的try语句。
5。堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置

7.5记录日志
1.要生成简单的日志记录，可以使用全局日志记录器(global logger)并调用其info方法:Logger.getClobal0,info("File->Open menu item selected");
2。如果在适当的地方(如 main开始)调用Logger.getClobal().setLevel(Level.OFF);
将会取消所有的日志。
3.在一个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。
可以调用getLogger方法创建或获取记录器:
private static final Logger myLogger = Logger.getLogger("com.mycompany.myapp"):
4.对于所有的级别有下面几种记录方法:
logger.warning(message) : logger, fine(message) ;
同时，还可以使用log方法指定级别，例如:logger.log(Level.FINE,message);
7.6调试技巧

